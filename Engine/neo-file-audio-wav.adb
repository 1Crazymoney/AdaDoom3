--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
separate(Neo.File.Audio)
package body WAV
  is
  end WAV;
--  ================================================
--  idWaveFile is used for reading generic RIFF WAVE files.
--  ================================================
--  */
--  class idWaveFile {
--  public:
--         ID_INLINE     idWaveFile();
--         ID_INLINE     ~idWaveFile();
--
--         bool          Open( const char * filename );
--         void          Close();
--         uint32        SeekToChunk( uint32 id );
--         size_t        Read( void * buffer, size_t len ) { return file->Read( buffer, len ); }
--         uint32        GetChunkOffset( uint32 id );
--
--         ID_TIME_T     Timestamp() { return file->Timestamp(); }
--         const char * Name() { return ( file == NULL ? "" : file->GetName() ); }
--
--         // This maps to the channel mask in waveFmtExtensible_t
--         enum {
--                CHANNEL_INDEX_FRONT_LEFT,
--                CHANNEL_INDEX_FRONT_RIGHT,
--                CHANNEL_INDEX_FRONT_CENTER,
--                CHANNEL_INDEX_LOW_FREQUENCY,
--                CHANNEL_INDEX_BACK_LEFT,
--                CHANNEL_INDEX_BACK_RIGHT,
--                CHANNEL_INDEX_FRONT_LEFT_CENTER,
--                CHANNEL_INDEX_FRONT_RIGHT_CENTER,
--                CHANNEL_INDEX_BACK_CENTER,
--                CHANNEL_INDEX_SIDE_LEFT,
--                CHANNEL_INDEX_SIDE_RIGHT,
--                CHANNEL_INDEX_MAX
--         };
--         enum {
--                CHANNEL_MASK_FRONT_LEFT                   = BIT( CHANNEL_INDEX_FRONT_LEFT ),
--                CHANNEL_MASK_FRONT_RIGHT           = BIT( CHANNEL_INDEX_FRONT_RIGHT ),
--                CHANNEL_MASK_FRONT_CENTER          = BIT( CHANNEL_INDEX_FRONT_CENTER ),
--                CHANNEL_MASK_LOW_FREQUENCY         = BIT( CHANNEL_INDEX_LOW_FREQUENCY ),
--                CHANNEL_MASK_BACK_LEFT                    = BIT( CHANNEL_INDEX_BACK_LEFT ),
--                CHANNEL_MASK_BACK_RIGHT                   = BIT( CHANNEL_INDEX_BACK_RIGHT ),
--                CHANNEL_MASK_FRONT_LEFT_CENTER     = BIT( CHANNEL_INDEX_FRONT_LEFT_CENTER ),
--                CHANNEL_MASK_FRONT_RIGHT_CENTER    = BIT( CHANNEL_INDEX_FRONT_RIGHT_CENTER ),
--                CHANNEL_MASK_BACK_CENTER           = BIT( CHANNEL_INDEX_BACK_CENTER ),
--                CHANNEL_MASK_SIDE_LEFT                    = BIT( CHANNEL_INDEX_SIDE_LEFT ),
--                CHANNEL_MASK_SIDE_RIGHT                   = BIT( CHANNEL_INDEX_SIDE_RIGHT ),
--                CHANNEL_MASK_ALL                          = BIT( CHANNEL_INDEX_MAX ) - 1,
--         };
--
--         // This matches waveFmt_t::formatTag
--         // These are the only wave formats that we understand
--         enum {
--                FORMAT_UNKNOWN              = 0x0000,
--                FORMAT_PCM                  = 0x0001,
--                FORMAT_ADPCM         = 0x0002,
--                FORMAT_XMA2                 = 0x0166,
--                FORMAT_EXTENSIBLE    = 0xFFFF,
--         };
--
--  #pragma pack( push, 1 )
--         struct waveFmt_t {
--                static const uint32 id = 'fmt ';
--                // This is the basic data we'd expect to see in any valid wave file
--                struct basic_t {
--                       uint16 formatTag;
--                       uint16 numChannels;
--                       uint32 samplesPerSec;
--                       uint32 avgBytesPerSec;
--                       uint16 blockSize;
--                       uint16 bitsPerSample;
--                } basic;
--                // Some wav file formats have extra data after the basic header
--                uint16 extraSize;
--                // We have a few known formats that we handle:
--                union extra_t {
--                       // Valid if basic.formatTag == FORMAT_EXTENSIBLE
--                       struct extensible_t {
--                              uint16 validBitsPerSample;  // Valid bits in each sample container
--                              uint32 channelMask;                // Positions of the audio channels
--                              struct guid_t {
--                                     uint32 data1;
--                                     uint16 data2;
--                                     uint16 data3;
--                                     uint16 data4;
--                                     byte data5[ 6 ];
--                              } subFormat;                       // Format identifier GUID
--                       } extensible;
--                       // Valid if basic.formatTag == FORMAT_ADPCM
--                       // The microsoft ADPCM struct has a zero-sized array at the end
--                       // but the array is always 7 entries, so we set it to that size
--                       // so we can embed it in our format union.  Otherwise, the struct
--                       // is exactly the same as the one in audiodefs.h
--                       struct adpcm_t {
--                              uint16 samplesPerBlock;
--                              uint16 numCoef;
--                              struct adpcmcoef_t {
--                                     short coef1;
--                                     short coef2;
--                              } aCoef[7];  // Always 7 coefficient pairs for MS ADPCM
--                       } adpcm;
--                       // Valid if basic.formatTag == FORMAT_XMA2
--                       struct xma2_t {
--                              uint16 numStreams;          // Number of audio streams (1 or 2 channels each)
--                              uint32 channelMask;         // matches the CHANNEL_MASK enum above
--                              uint32 samplesEncoded;      // Total number of PCM samples the file decodes to
--                              uint32 bytesPerBlock;       // XMA block size (but the last one may be shorter)
--                              uint32 playBegin;           // First valid sample in the decoded audio
--                              uint32 playLength;          // Length of the valid part of the decoded audio
--                              uint32 loopBegin;           // Beginning of the loop region in decoded sample terms
--                              uint32 loopLength;          // Length of the loop region in decoded sample terms
--                              byte   loopCount;           // Number of loop repetitions; 255 = infinite
--                              byte   encoderVersion;      // Version of XMA encoder that generated the file
--                              uint16 blockCount;          // XMA blocks in file (and entries in its seek table)
--                       } xma2;
--                } extra;
--         };
--
--  #pragma pack( pop )
--
--         struct dataChunk_t {
--                static const uint32 id = 'data';
--                uint32 size;
--                void * data;
--         };
--
--         struct formatChunk_t {
--                static const uint32 id = 'fmt ';
--                uint32 size;
--                uint16 compressionCode;
--                uint16 numChannels;
--                uint32 sampleRate;
--                uint32 averageBytesPerSecond;
--                uint16 blockAlign;
--                uint16 bitsPerSample;
--                uint16 numExtraFormatByte;
--         };
--
--         struct samplerChunk_t {
--                static const uint32 id = 'smpl';
--                uint32 manufacturer;        // ignored
--                uint32 product;                           // ignored
--                uint32 samplePeriod;        // ignored (normally 1000000000/samplesPerSec)
--                uint32 MIDIUnityNote;              // ignored
--                uint32 MIDIPitchFraction;   // ignored
--                uint32 SMPTEFormat;                // ignored
--                uint32 SMPTEOffset;                // ignored
--                uint32 numSampleLoops;             // number of samples in wave file
--                uint32 extraSamplerData;    // ignored, should always be 0
--         };
--
--         struct sampleData_t {
--                uint32 identifier;          // ignored
--                uint32 type;                // 0 for loop 33 multi-sample sample type
--                uint32 start;               // start of the loop point
--                uint32 end;                        // end of the loop point
--                uint32 fraction;            // ignored
--                uint32 playCount;           // ignored
--         };
--
--         const char * ReadWaveFormat( waveFmt_t & waveFmt );
--         static bool  ReadWaveFormatDirect( waveFmt_t & format, idFile *file );
--         static bool  WriteWaveFormatDirect( waveFmt_t & format, idFile *file );
--         static bool  WriteSampleDataDirect( idList< sampleData_t > & sampleData, idFile *file );
--         static bool  WriteDataDirect( char * _data, uint32 size, idFile * file );
--         static bool  WriteHeaderDirect( uint32 fileSize, idFile * file );
--
--         bool           ReadLoopData( int & start, int & end );
--
--  private:
--         idFile *                                  file;
--
--         struct chunk_t {
--                uint32 id;
--                uint32 size;
--                uint32 offset;
--         };
--
--         idStaticList< chunk_t, 32 > chunks;
--
--
--  };
--
--  /*
--  ========================
--  idWaveFile::idWaveFile
--  ========================
--  */
--  ID_INLINE idWaveFile::idWaveFile() : file( NULL ) {
--  }
--
--  /*
--  ========================
--  idWaveFile::~idWaveFile
--  ========================
--  */
--  ID_INLINE idWaveFile::~idWaveFile() {
--         Close();
--  }
--
--  #endif // !__WAVEFILE_H__
--
--  /*
--  ========================
--  idWaveFile::Open
--
--  Returns true if the Open was successful and the file matches the expected format. If this
--  returns false, there is no need to call Close.
--  ========================
--  */
--  bool idWaveFile::Open( const char * filename ) {
--         Close();
--
--         if ( filename == NULL || filename[0] == 0 ) {
--                return false;
--         }
--
--         if ( file == NULL ) {
--                file = fileSystem->OpenFileReadMemory( filename );
--                if ( file == NULL ) {
--                       return false;
--                }
--         }
--
--         if ( file->Length() == 0 ) {
--                Close();
--                return false;
--         }
--
--         struct header_t {
--                uint32 id;
--                uint32 size;
--                uint32 format;
--         } header;
--
--         file->Read( &header, sizeof( header ) );
--         idSwap::Big( header.id );
--         idSwap::Little( header.size );
--         idSwap::Big( header.format );
--
--         if ( header.id != 'RIFF' || header.format != 'WAVE' || header.size < 4 ) {
--                Close();
--                idLib::Warning( "Header is not RIFF WAVE in %s", filename );
--                return false;
--         }
--
--         uint32 riffSize = header.size + 8;
--         uint32 offset = sizeof( header );
--
--         // Scan the file collecting chunks
--         while ( offset < riffSize ) {
--                struct chuckHeader_t {
--                       uint32 id;
--                       uint32 size;
--                } chunkHeader;
--                if ( file->Read( &chunkHeader, sizeof( chunkHeader ) ) != sizeof( chunkHeader ) ) {
--                       // It seems like some tools have extra data after the last chunk for no apparent reason
--                       // so don't treat this as an error
--                       return true;
--                }
--                idSwap::Big( chunkHeader.id );
--                idSwap::Little( chunkHeader.size );
--                offset += sizeof( chunkHeader );
--
--                if ( chunks.Num() >= chunks.Max() ) {
--                       Close();
--                       idLib::Warning( "More than %d chunks in %s", chunks.Max(), filename );
--                       return false;
--                }
--
--                chunk_t * chunk = chunks.Alloc();
--                chunk->id = chunkHeader.id;
--                chunk->size = chunkHeader.size;
--                chunk->offset = offset;
--                offset += chunk->size;
--
--                file->Seek( offset, FS_SEEK_SET );
--         }
--
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::SeekToChunk
--
--  Seeks to the specified chunk and returns the size of the chunk or 0 if the chunk wasn't found.
--  ========================
--  */
--  uint32 idWaveFile::SeekToChunk( uint32 id ) {
--         for ( int i = 0; i < chunks.Num(); i++ ) {
--                if ( chunks[i].id == id ) {
--                       file->Seek( chunks[i].offset, FS_SEEK_SET );
--                       return chunks[i].size;
--                }
--         }
--         return 0;
--  }
--
--  /*
--  ========================
--  idWaveFile::GetChunkOffset
--
--  Seeks to the specified chunk and returns the size of the chunk or 0 if the chunk wasn't found.
--  ========================
--  */
--  uint32 idWaveFile::GetChunkOffset( uint32 id ) {
--         for ( int i = 0; i < chunks.Num(); i++ ) {
--                if ( chunks[i].id == id ) {
--                       return chunks[i].offset;
--                }
--         }
--         return 0;
--  }
--
--  // Used in XMA2WAVEFORMAT for per-stream data
--  typedef struct XMA2STREAMFORMAT {
--      byte Channels;                 // Number of channels in the stream (1 or 2)
--      byte RESERVED;                 // Reserved for future use
--      uint16 ChannelMask;            // Spatial positions of the channels in the stream
--  } XMA2STREAMFORMAT;
--
--  // Legacy XMA2 format structure (big-endian byte ordering)
--  typedef struct XMA2WAVEFORMAT {
--      byte Version;                  // XMA encoder version that generated the file.
--                                                   // Always 3 or higher for XMA2 files.
--      byte NumStreams;        // Number of interleaved audio streams
--      byte RESERVED;                 // Reserved for future use
--      byte LoopCount;                // Number of loop repetitions; 255 = infinite
--      uint32 LoopBegin;              // Loop begin point, in samples
--      uint32 LoopEnd;                // Loop end point, in samples
--      uint32 SampleRate;             // The file's decoded sample rate
--      uint32 EncodeOptions;          // Options for the XMA encoder/decoder
--      uint32 PsuedoBytesPerSec;      // Used internally by the XMA encoder
--      uint32 BlockSizeInBytes;       // Size in bytes of this file's XMA blocks (except
--                                                          // possibly the last one).  Always a multiple of
--                                                          // 2Kb, since XMA blocks are arrays of 2Kb packets.
--      uint32 SamplesEncoded;         // Total number of PCM samples encoded in this file
--      uint32 SamplesInSource;        // Actual number of PCM samples in the source
--                                                          // material used to generate this file
--      uint32 BlockCount;                    // Number of XMA blocks in this file (and hence
--                                                          // also the number of entries in its seek table)
--  } XMA2WAVEFORMAT;
--
--  /*
--  ========================
--  idWaveFile::ReadWaveFormat
--
--  Reads a wave format header, returns NULL if it found one and read it.
--  otherwise, returns a human-readable error message.
--  ========================
--  */
--  const char * idWaveFile::ReadWaveFormat( waveFmt_t & format ) {
--         memset( &format, 0, sizeof( format ) );
--
--         uint32 formatSize = SeekToChunk( waveFmt_t::id );
--         if ( formatSize == 0 ) {
--                return "No format chunk";
--         }
--         if ( formatSize < sizeof( format.basic ) ) {
--                return "Format chunk too small";
--         }
--
--         Read( &format.basic, sizeof( format.basic ) );
--
--         idSwapClass<waveFmt_t::basic_t> swap;
--         swap.Little( format.basic.formatTag );
--         swap.Little( format.basic.numChannels );
--         swap.Little( format.basic.samplesPerSec );
--         swap.Little( format.basic.avgBytesPerSec );
--         swap.Little( format.basic.blockSize );
--         swap.Little( format.basic.bitsPerSample );
--
--         if ( format.basic.formatTag == FORMAT_PCM ) {
--         } else if ( format.basic.formatTag == FORMAT_ADPCM ) {
--                Read( &format.extraSize, sizeof( format.extraSize ) );
--                idSwap::Little( format.extraSize );
--                if ( format.extraSize != sizeof( waveFmt_t::extra_t::adpcm_t ) ) {
--                       return "Incorrect number of coefficients in ADPCM file";
--                }
--                Read( &format.extra.adpcm, sizeof( format.extra.adpcm ) );
--                idSwapClass<waveFmt_t::extra_t::adpcm_t> swap;
--                swap.Little( format.extra.adpcm.samplesPerBlock );
--                swap.Little( format.extra.adpcm.numCoef );
--                for ( int i = 0; i < format.extra.adpcm.numCoef; i++ ) {
--                       swap.Little( format.extra.adpcm.aCoef[ i ].coef1 );
--                       swap.Little( format.extra.adpcm.aCoef[ i ].coef2 );
--                }
--         } else if ( format.basic.formatTag == FORMAT_XMA2 ) {
--                Read( &format.extraSize, sizeof( format.extraSize ) );
--                idSwap::Little( format.extraSize );
--                if ( format.extraSize != sizeof( waveFmt_t::extra_t::xma2_t ) ) {
--                       return "Incorrect chunk size in XMA2 file";
--                }
--                Read( &format.extra.xma2, sizeof( format.extra.xma2 ) );
--                idSwapClass<waveFmt_t::extra_t::xma2_t> swap;
--                swap.Little( format.extra.xma2.numStreams );
--                swap.Little( format.extra.xma2.channelMask );
--                swap.Little( format.extra.xma2.samplesEncoded );
--                swap.Little( format.extra.xma2.bytesPerBlock );
--                swap.Little( format.extra.xma2.playBegin );
--                swap.Little( format.extra.xma2.playLength );
--                swap.Little( format.extra.xma2.loopBegin );
--                swap.Little( format.extra.xma2.loopLength );
--                swap.Little( format.extra.xma2.loopCount );
--                swap.Little( format.extra.xma2.encoderVersion );
--                swap.Little( format.extra.xma2.blockCount );
--         } else if ( format.basic.formatTag == FORMAT_EXTENSIBLE ) {
--                Read( &format.extraSize, sizeof( format.extraSize ) );
--                idSwap::Little( format.extraSize );
--                if ( format.extraSize != sizeof( waveFmt_t::extra_t::extensible_t ) ) {
--                       return "Incorrect chunk size in extensible wave file";
--                }
--                Read( &format.extra.extensible, sizeof( format.extra.extensible ) );
--                idSwapClass<waveFmt_t::extra_t::extensible_t> swap;
--                swap.Little( format.extra.extensible.validBitsPerSample );
--                swap.Little( format.extra.extensible.channelMask );
--                swap.Little( format.extra.extensible.subFormat.data1 );
--                swap.Little( format.extra.extensible.subFormat.data2 );
--                swap.Little( format.extra.extensible.subFormat.data3 );
--                swap.Little( format.extra.extensible.subFormat.data4 );
--                swap.LittleArray( format.extra.extensible.subFormat.data5, 6 );
--                waveFmt_t::extra_t::extensible_t::guid_t pcmGuid = {
--                       FORMAT_PCM,
--                       0x0000,
--                       0x0010,
--                       0x8000,
--                       { 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 }
--                };
--                if ( memcmp( &pcmGuid, &format.extra.extensible.subFormat, sizeof( pcmGuid ) ) != 0 ) {
--                       return "Unsupported Extensible format";
--                }
--         } else {
--                return "Unknown wave format tag";
--         }
--
--         return NULL;
--  }
--
--  /*
--  ========================
--  idWaveFile::ReadWaveFormatDirect
--
--  Reads a wave format header from a file ptr,
--  ========================
--  */
--  bool idWaveFile::ReadWaveFormatDirect( waveFmt_t & format, idFile *file ) {
--
--         file->Read( &format.basic, sizeof( format.basic ) );
--         idSwapClass<waveFmt_t::basic_t> swap;
--         swap.Little( format.basic.formatTag );
--         swap.Little( format.basic.numChannels );
--         swap.Little( format.basic.samplesPerSec );
--         swap.Little( format.basic.avgBytesPerSec );
--         swap.Little( format.basic.blockSize );
--         swap.Little( format.basic.bitsPerSample );
--
--         if ( format.basic.formatTag == FORMAT_PCM ) {
--         } else if ( format.basic.formatTag == FORMAT_ADPCM ) {
--                file->Read( &format.extraSize, sizeof( format.extraSize ) );
--                idSwap::Little( format.extraSize );
--                if ( format.extraSize != sizeof( waveFmt_t::extra_t::adpcm_t ) ) {
--                       return false;
--                }
--                file->Read( &format.extra.adpcm, sizeof( format.extra.adpcm ) );
--                idSwapClass<waveFmt_t::extra_t::adpcm_t> swap;
--                swap.Little( format.extra.adpcm.samplesPerBlock );
--                swap.Little( format.extra.adpcm.numCoef );
--                for ( int i = 0; i < format.extra.adpcm.numCoef; i++ ) {
--                       swap.Little( format.extra.adpcm.aCoef[ i ].coef1 );
--                       swap.Little( format.extra.adpcm.aCoef[ i ].coef2 );
--                }
--         } else if ( format.basic.formatTag == FORMAT_XMA2 ) {
--                file->Read( &format.extraSize, sizeof( format.extraSize ) );
--                idSwap::Little( format.extraSize );
--                if ( format.extraSize != sizeof( waveFmt_t::extra_t::xma2_t ) ) {
--                       return false;
--                }
--                file->Read( &format.extra.xma2, sizeof( format.extra.xma2 ) );
--                idSwapClass<waveFmt_t::extra_t::xma2_t> swap;
--                swap.Little( format.extra.xma2.numStreams );
--                swap.Little( format.extra.xma2.channelMask );
--                swap.Little( format.extra.xma2.samplesEncoded );
--                swap.Little( format.extra.xma2.bytesPerBlock );
--                swap.Little( format.extra.xma2.playBegin );
--                swap.Little( format.extra.xma2.playLength );
--                swap.Little( format.extra.xma2.loopBegin );
--                swap.Little( format.extra.xma2.loopLength );
--                swap.Little( format.extra.xma2.loopCount );
--                swap.Little( format.extra.xma2.encoderVersion );
--                swap.Little( format.extra.xma2.blockCount );
--         } else if ( format.basic.formatTag == FORMAT_EXTENSIBLE ) {
--                file->Read( &format.extraSize, sizeof( format.extraSize ) );
--                idSwap::Little( format.extraSize );
--                if ( format.extraSize != sizeof( waveFmt_t::extra_t::extensible_t ) ) {
--                       return false;
--                }
--                file->Read( &format.extra.extensible, sizeof( format.extra.extensible ) );
--                idSwapClass<waveFmt_t::extra_t::extensible_t> swap;
--                swap.Little( format.extra.extensible.validBitsPerSample );
--                swap.Little( format.extra.extensible.channelMask );
--                swap.Little( format.extra.extensible.subFormat.data1 );
--                swap.Little( format.extra.extensible.subFormat.data2 );
--                swap.Little( format.extra.extensible.subFormat.data3 );
--                swap.Little( format.extra.extensible.subFormat.data4 );
--                swap.LittleArray( format.extra.extensible.subFormat.data5, 6 );
--                waveFmt_t::extra_t::extensible_t::guid_t pcmGuid = {
--                       FORMAT_PCM,
--                       0x0000,
--                       0x0010,
--                       0x8000,
--                       { 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 }
--                };
--                if ( memcmp( &pcmGuid, &format.extra.extensible.subFormat, sizeof( pcmGuid ) ) != 0 ) {
--                       return false;
--                }
--         } else {
--                return false;
--         }
--
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::WriteWaveFormatDirect
--
--  Writes a wave format header to a file ptr,
--  ========================
--  */
--  bool idWaveFile::WriteWaveFormatDirect( waveFmt_t & format, idFile *file ) {
--         //idSwapClass<waveFmt_t::basic_t> swap;
--         //swap.Little( format.basic.formatTag );
--         //swap.Little( format.basic.numChannels );
--         //swap.Little( format.basic.samplesPerSec );
--         //swap.Little( format.basic.avgBytesPerSec );
--         //swap.Little( format.basic.blockSize );
--         //swap.Little( format.basic.bitsPerSample );
--         file->Write( &format.basic, sizeof( format.basic ) );
--         if ( format.basic.formatTag == FORMAT_PCM ) {
--                //file->Write( &format.basic, sizeof( format.basic ) );
--         } else if ( format.basic.formatTag == FORMAT_ADPCM ) {
--                //file->Write( &format.basic, sizeof( format.basic ) );
--                file->Write( &format.extraSize, sizeof( format.extraSize ) );
--                file->Write( &format.extra.adpcm, sizeof( format.extra.adpcm ) );
--         } else if ( format.basic.formatTag == FORMAT_XMA2 ) {
--                //file->Write( &format.basic, sizeof( format.basic ) );
--                file->Write( &format.extraSize, sizeof( format.extraSize ) );
--                file->Write( &format.extra.xma2, sizeof( format.extra.xma2 ) );
--         } else if ( format.basic.formatTag == FORMAT_EXTENSIBLE ) {
--                //file->Write( &format.basic, sizeof( format.basic ) );
--                file->Write( &format.extraSize, sizeof( format.extraSize ) );
--                file->Write( &format.extra.extensible, sizeof( format.extra.extensible ) );
--         } else {
--                return false;
--         }
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::WriteWaveFormatDirect
--
--  Writes a wave format header to a file ptr,
--  ========================
--  */
--
--  bool idWaveFile::WriteSampleDataDirect( idList< sampleData_t > & sampleData, idFile * file ) {
--         static const uint32 sample = 'smpl';
--         file->WriteBig( sample );
--         uint32 samplerData = sampleData.Num() * 24;
--         uint32 chunkSize = 36 + samplerData;
--         uint32 zero = 0;
--         uint32 numSamples = sampleData.Num();
--
--         file->Write( &chunkSize, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &zero, sizeof( uint32 ) );
--         file->Write( &numSamples, sizeof( uint32 ) );
--         file->Write( &samplerData, sizeof( uint32 ) );
--
--         for ( int i = 0; i < sampleData.Num(); ++i ) {
--                file->Write( &zero, sizeof( uint32 ) );
--                file->Write( &zero, sizeof( uint32 ) );
--                file->Write( &sampleData[ i ].start, sizeof( uint32 ) );
--                file->Write( &sampleData[ i ].end, sizeof( uint32 ) );
--                file->Write( &zero, sizeof( uint32 ) );
--                file->Write( &zero, sizeof( uint32 ) );
--         }
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::WriteWaveFormatDirect
--
--  Writes a data chunk to a file ptr
--  ========================
--  */
--
--  bool idWaveFile::WriteDataDirect( char * _data, uint32 size, idFile * file ) {
--         static const uint32 data = 'data';
--         file->WriteBig( data );
--         file->Write( &size, sizeof( uint32 ) );
--         file->WriteBigArray( _data, size );
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::WriteWaveFormatDirect
--
--  Writes a wave header to a file ptr,
--  ========================
--  */
--
--  bool idWaveFile::WriteHeaderDirect( uint32 fileSize, idFile * file ) {
--         static const uint32 riff = 'RIFF';
--         static const uint32 wave = 'WAVE';
--         file->WriteBig( riff );
--         file->WriteBig( fileSize );
--         file->WriteBig( wave );
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::ReadLoopPoint
--
--  Reads a loop point from a 'smpl' chunk in a wave file, returns 0 if none are found.
--  ========================
--  */
--  bool idWaveFile::ReadLoopData( int & start, int & end ) {
--         uint32 chunkSize = SeekToChunk( samplerChunk_t::id );
--         if ( chunkSize < sizeof( samplerChunk_t ) ) {
--                return false;
--         }
--
--         samplerChunk_t smpl;
--         Read( &smpl, sizeof( smpl ) );
--         idSwap::Little( smpl.numSampleLoops );
--
--         if ( smpl.numSampleLoops < 1 ) {
--                return false; // this is possible returning false lets us know there are more then 1 sample look in the file and is not appropriate for traditional looping
--         }
--
--         sampleData_t smplData;
--         Read( &smplData, sizeof( smplData ) );
--         idSwap::Little( smplData.start );
--         idSwap::Little( smplData.end );
--
--         if ( smplData.type != 0 ) {
--                idLib::Warning( "Invalid loop type in %s", file->GetName() );
--                return false;
--         }
--
--         start = smplData.start;
--         end = smplData.end;
--         return true;
--  }
--
--  /*
--  ========================
--  idWaveFile::Close
--
--  Closes the file and frees resources.
--  ========================
--  */
--  void idWaveFile::Close() {
--         if ( file != NULL ) {
--                delete file;
--                file = NULL;
--         }
--         chunks.SetNum( 0 );
}
